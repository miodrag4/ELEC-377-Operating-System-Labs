{\rtf1\ansi\ansicpg1252\cocoartf2639
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fmodern\fcharset0 Courier;\f1\fmodern\fcharset0 Courier-Oblique;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red255\green255\blue255;}
{\*\expandedcolortbl;;\cssrgb\c0\c1\c1;\cssrgb\c100000\c100000\c99985;}
\margl1440\margr1440\vieww14620\viewh16220\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs26 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec3 //ELEC 377 Lab 3 Documentation\
//Kieran Cosgrove, Mile Stosic\
\
//Problem Statement and Objectives\
The objective of Lab 3 was to incorporate C function pointers and practice using lower level C memory representation. Furthermore, the Lab 3 required the use of Linux system calls to retrieve system information and start a process.\
\
//Layout of the Code and How it Works\
To implement the objectives of the lab, a shell was written to implement built-in commands and run external programs and a restricted seat of library routines were used to develop a further understanding of the memory model underlying programming low level operating systems services and modules. \
\
Inputs were separated into words in the 
\f1\i commandBuffer 
\f0\i0 array. There is a second array called 
\f1\i args
\f0\i0  that is an array of character pointers that will point to each of the words in the 
\f1\i commandBuffer
\f0\i0  array. The 
\f1\i splitCommandLine
\f0\i0  function is responsible for this separation and takes arguments from the two arrays and the maximum number of 
\f1\i args
\f0\i0 . The index after each word is set to null to indicate a words termination.\
\
\
The next function that was implemented was the 
\f1\i skipChar 
\f0\i0 function. Its purpose is to skip the character given by its second parameter. If the skipped character is null, it returns the pointer it was given unchanged. 
\f1\i splitCommandLine
\f0\i0  calls skipChar as well as the library function 
\f1\i strchr
\f0\i0  and 
\f1\i fprintf. 
\f0\i0 The function 
\f1\i fprintf
\f0\i0  takes a  predefined stderr file as the first parameter. Note, that for our particular code, we chose to use a while loop to iterate through instead of using 
\f1\i strchr
\f0\i0  because the former was causing errors due to its properties.\
\
The second stage of the lab is to implement the internal commands: exit, pwd, ls, and cd. This is done using the function 
\f1\i doInternal
\f0\i0  with the argument array and number of 
\f1\i args
\f0\i0 . A prototype was added to help implement the exit command before the dispatch table and definition of the function is added to the bottom of the file. Similarly, 
\f1\i getcwd 
\f0\i0 library is used for 
\f1\i pwd 
\f0\i0 command and 
\f1\i ls
\f0\i0  and 
\f1\i cd
\f0\i0  take optional arguments. The 
\f1\i cd
\f0\i0  commands uses a pointer to the password file enter of a user using the function 
\f1\i getpwuid
\f0\i0 ; if null return an error. For 
\f1\i ls
\f0\i0  command, the 
\f1\i scandir
\f0\i0  function is used to list the contents of a directory and uses pointers to a directory entity called 
\f1\i dirent 
\f0\i0 to store an array of pointers to 
\f1\i dirents
\f0\i0  in the pointer.\
\
The main program\'92s code that checks the number of arguments is greater than zero and then calls 
\f1\i doInternalCommand
\f0\i0  to call 
\f1\i doProgram
\f0\i0  if zero was changed.
\f1\i  
\f0\i0 If value returned by 
\f1\i doProgram
\f0\i0  is zero, then it prints an error message. Within the 
\f1\i doProgram
\f0\i0 , the 
\f1\i strlen
\f0\i0  function is used to find length of the current element of earth and the length of the first element of the args array and then uses malloc to allocate enough space for the path, a \'91/\'91 character and the command. 
\f1\i Sprintf
\f0\i0  is used to fill the string.}