
//+
// File: common.c
//
// Purpose: Suport functions used as part of ELEC 277 Lab 2.
//
// Copyright 2022 Iffy Maduabuchi, Thomas Dean
//-

#include <errno.h>
#include <stdarg.h>

#include "common.h"


//---------------------------------------------------
// MONITOR FUNCTIONS --------------------------------
//---------------------------------------------------


void * monitor_thread_func( void * p ){
        struct monitor_thread_info * info = (struct monitor_thread_info *) p;

        int retval = monitor_function(info->machine_number, info->shmemptr);

        pthread_exit(0);
}

int monitor_function(int machine_number, struct shared_segment * shmemptr ){

    char machine_file_name[25]; // allow for 10 digit 32 bit number just in case.
    char  line[100];
    sprintf(machine_file_name,"machine_%d.txt",machine_number);

#ifdef TESTING_VERBOSE
    testLog(machId[machine_number],"thread %d, file name is %s", machine_number, machine_file_name);
#endif

    FILE * machine_fp = fopen(machine_file_name,"r");
    if (machine_fp == NULL){
        fprintf(stderr,"Could not open machine description file %s\n", machine_file_name);
        return 1;
    }
    
    // increment nubmer of monitors
    if (sem_wait(access_stats) == -1){
        perror("monitor entry critical section failed");
        exit(1);
    }
    shmemptr->numMonitors++;
    if (sem_post(access_stats) == -1){
        perror("monitor entry critical section failed");
        exit(1);
    }
    
#ifdef THREAD_VERBOSE
   threadLog(machId[machine_number],"Machine %d started", machine_number);
#endif

    struct status cur_read_stat;

    // model of commuication delay, time to wait before
    // posting data to the shared status
    int current_delay;

    int status_id = -1;

    while (fgets(line,100,machine_fp)){
        status_id++;
        unsigned long linelen=strlen(line);
        if (line[linelen -1] == '\n'){
            line[linelen-1] = '\0';
        }

        //testLog(machId[machine_number],"line %d: %s", status_id,line);

        int numVals = sscanf(line, "%d,%d,%f,%d,%d,%d",
                        &(cur_read_stat.machine_state),
                        &(cur_read_stat.num_of_processes),
                        &(cur_read_stat.load_factor),
                        &(cur_read_stat.packets_per_second),
                        &(cur_read_stat.discards_per_second),
                        &current_delay);

        // check that we got 6 values from the line. If not, over
        if (numVals != 6) {
            fprintf(stderr, "%s: error on line %d of %s: not enough values\n",
                progname, status_id+1, machine_file_name);
            fclose(machine_fp);
            return 1;
        }



        cur_read_stat.timestamp= get_current_unix_time();

        if (cur_read_stat.machine_state == 0){
            // make sure all values are 0
            cur_read_stat.num_of_processes = 0;
            cur_read_stat.load_factor = 0.0;
            cur_read_stat.packets_per_second = 0;
            cur_read_stat.discards_per_second = 0;
        }

        monitor_update_status_entry(machine_number, status_id, &cur_read_stat, shmemptr);
#ifdef THREAD_VERBOSE
        threadLog(machId[machine_number],"Sleeping for %d msec", current_delay);
#endif
        msleep(current_delay);
   }
    
   fclose(machine_fp);
    
    // increment nubmer of monitors
    if (sem_wait(access_stats) == -1){
        perror("monitor entry critical section failed");
        exit(1);
    }
    shmemptr->numMonitors--;
    if (sem_post(access_stats) == -1){
        perror("monitor entry critical section failed");
        exit(1);
    }
   return 0;

}

//---------------------------------------------------
// Checksum FUNCTIONS --------------------------------
//---------------------------------------------------

// generates a random seed for the checksunm
int gen_checksum_seed(){
        return rand_lim(1001, 5000, 1);
}

// get initial value for checksum
// generated value is unique to checksum_seed, machine_id and time_stamp
long init_checksum (int checksum_seed, int machine_id , unsigned timestamp){
    // arbitrary initialization calculation
    // aimed for dependency such that each parameter will change the output value
    return (unsigned long long)((long)(timestamp) * (long)(( (machine_id * machine_id * 13) + (machine_id * checksum_seed) ) % (machine_id + 29)));
}

// fortify the checksum using the iterations
// take the initial checksum generated by init_checksum
// fortifications are unique to machine_id and time_stamp
long make_checksum ( long checksum, int machine_id, unsigned timestamp, unsigned long long iterations){
    // arbitrary calculation and iterations intended to take time
    // the more the iterations the longer the calculation will take
    // also generates specific number based on iteration
    // iterations >= BASIC_CHECKSUM_ITRS will take seconds to complete
    volatile unsigned long long i;
    for (i = 0; i < iterations; ++i){
	checksum = (long)((i + (machine_id*machine_id) + (unsigned long long)checksum) % (unsigned long long)(machine_id + timestamp));
    }
    return checksum;
}

long status_checksum(int checksum_seed, int machine_id,unsigned timestamp){
    
    long checksum = init_checksum( checksum_seed, machine_id, timestamp);
    checksum = make_checksum( checksum, machine_id, timestamp, BASIC_CHECKSUM_ITRS );

    return checksum;
}

// generates the checksum used in the summary struct
long gen_summary_checksum(){
    unsigned unix_time = get_current_unix_time();
    int checksum_seed = gen_checksum_seed();

    long checksum = init_checksum( checksum_seed, MAX_MACHINES, unix_time);
    checksum = make_checksum( checksum, MAX_MACHINES, unix_time, MINIMAL_CHECKSUM_ITRS );

    return checksum;
}

//---------------------------------------------------
// Utility FUNCTIONS --------------------------------
//---------------------------------------------------

// get the current unix time
unsigned get_current_unix_time(){
        return (unsigned)time(NULL);
}

// sleep the specified amount of time in milliseconds
void msleep(unsigned int tms) {
        usleep(tms * 1000);
}

// generate a random value in range [start, end) in increments of step
int rand_lim(int start, int end, int step){
        // calculate the random number within our limit
        // range is 0 to n, so limit is end - start
        int limit = end-start;
        int divisor = RAND_MAX/(limit+1);
    int base_random;

    do {
        base_random = rand() / divisor;
    } while (base_random > limit);

    // shift value up into our start and end range
        int random_value = base_random + start;

        // round the vlaue to the specified step
        if (step == 0)
        return random_value;

    int remainder = random_value % step;
    if (remainder == 0)
        return random_value;

    return random_value + step - remainder;
}


// write message to console in test logging colour (GREEN)
void testLog(char entity, const char * format, ...){
    va_list args;

    as_log(entity,CONSOLE_PURPLE);

    va_start(args,format);
    vprintf(format,args);
    va_end(args);

    end_log();
}

// write message to console in thread loggin colour (GREEN)
void threadLog(char entity, const char * format, ...){
    va_list args;

    as_log(entity,CONSOLE_YELLOW);

    va_start(args,format);
    vprintf(format,args);
    va_end(args);

    end_log();
}

void colourMsg(char entity, const char * colour, const char * format, ...){
    va_list args;

    as_log(entity,colour);

    va_start(args,format);
    vprintf(format,args);
    va_end(args);

    end_log();
}

//---------------------------------------------------
// CONSOLE FUNCTIONS --------------------------------
//---------------------------------------------------

char machId[] = {
 '0', '1', '2', '3', '4', '5', '6', '7',
 '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
};

// sets the colour of text printed to the console to the specifed colour code
// can use CONSOLE_* defined in common.h
void set_colour(const char * colour_code){
	fputs(colour_code, stdout);
}

// resets console colour to default
void reset_colour(){
	printf(CONSOLE_DEFAULT);
}

// prints the current unix time , sets the console to a specific colour
// used in logging
void as_log(char entity, const char * colour_code) {
	set_colour(colour_code);
	//printf("[%f] ", get_current_micro_unix_time());
	struct timeval tv;
	gettimeofday(&tv, NULL);
	printf("%c [%ld.%06d] ", entity, tv.tv_sec, tv.tv_usec);
}

// ends the log to the console,
void end_log(){
	reset_colour();
	printf("\n");
}

